<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[于成辉的博客]]></title>
  <link href="http://chyufly.github.io/atom.xml" rel="self"/>
  <link href="http://chyufly.github.io/"/>
  <updated>2016-07-12T22:44:21+08:00</updated>
  <id>http://chyufly.github.io/</id>
  <author>
    <name><![CDATA[chyu]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[多机环境下虚拟网络实现机制（三）]]></title>
    <link href="http://chyufly.github.io/blog/2016/07/11/understanding-neutron-north-south-east-west/"/>
    <updated>2016-07-11T22:48:58+08:00</updated>
    <id>http://chyufly.github.io/blog/2016/07/11/understanding-neutron-north-south-east-west</id>
    <content type="html"><![CDATA[<h1>&mdash;  <strong><em>南北、东西流量网络实现原理</em></strong></h1>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多机环境下虚机网络实现机制（二）]]></title>
    <link href="http://chyufly.github.io/blog/2016/07/11/understanding-neutron-vlan-vxlan/"/>
    <updated>2016-07-11T22:47:53+08:00</updated>
    <id>http://chyufly.github.io/blog/2016/07/11/understanding-neutron-vlan-vxlan</id>
    <content type="html"><![CDATA[<h1>&mdash;  <strong><em>VLAN和VXLAN流表实现机制</em></strong></h1>

<hr />

<h2>1、neutron中的网络概念</h2>

<h3>1.1 网络的命名空间</h3>

<p>   在 neutron中，网络名字空间可以被认为是隔离的拥有单独网络栈（网卡、路由转发表、iptables）的环境，只有拥有同样网络名字空间的设备,才能看到彼此。namespace的好处就是可以隔离网络设备和服务，在neutron中，使用ip netns来列举出所有的命名空间。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@host41 ~]# ip netns
</span><span class='line'>qrouter-ec5e63fc-c5a4-4925-9767-154583432d21
</span><span class='line'>qdhcp-ce0869f1-b055-4914-85f9-9398bad6de7c
</span><span class='line'>qdhcp-3a14c59d-37f1-42a7-a135-29466583d3e2
</span><span class='line'>qrouter-af687a92-d701-4372-8bb2-b922aee494da
</span><span class='line'>qdhcp-6fc3d619-81d9-4c1a-9080-16fd12321735
</span><span class='line'>qdhcp-8c4abc35-ac62-480d-92ce-ec056b4af3d0
</span><span class='line'>qdhcp-8afb20c6-8c55-41fd-9b9d-bce61aaa8bd7
</span><span class='line'>qdhcp-2a70f3da-d722-4cc4-85e8-9b4e19366106
</span><span class='line'>qdhcp-cdbead44-deb9-42a1-901e-53db3bb6e80f
</span><span class='line'>qdhcp-cf4fee75-358b-46ba-bb88-525aa0be2e36
</span><span class='line'>qdhcp-2c9471bf-e5f7-447e-82d4-55fa29fe9058
</span><span class='line'>qrouter-965d88e2-6d5a-4be3-b8d7-32c0a247245f
</span><span class='line'>qrouter-54aa7fd1-f3d5-4f0e-9bbd-2e8be54b7228
</span><span class='line'>qrouter-03347f01-d551-46ac-944c-2ed83e79362f
</span></code></pre></td></tr></table></div></figure>


<p>以qdhcp开头的是DHCP服务的命名空间，以qrouter开头的是路由器服务的命名空间。
为了方便的使用namespace，可以使用<em>ip netns exec namespaceID commond</em>来对命名空间进行操作，如下所示：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@host41 ~]# ip netns exec qrouter-ec5e63fc-c5a4-4925-9767-154583432d21 route -n
</span><span class='line'>Kernel IP routing table
</span><span class='line'>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
</span><span class='line'>0.0.0.0         172.21.11.1     0.0.0.0         UG    0      0        0 qg-4306bf11-af
</span><span class='line'>10.0.1.0        0.0.0.0         255.255.255.0   U     0      0        0 qr-4d5301c0-7c
</span><span class='line'>10.1.0.0        0.0.0.0         255.255.255.0   U     0      0        0 qr-c4a064a6-c5
</span><span class='line'>172.21.11.0     0.0.0.0         255.255.255.0   U     0      0        0 qg-4306bf11-af</span></code></pre></td></tr></table></div></figure>


<h3>1.2 Security Group的概念</h3>

<p>Security group是一些规则的集合，用来对虚拟机的访问流量进行控制，起到虚拟防火墙的作用，在启动虚拟机的实例时，可以将一个或者多个安全组与该实例关联，在nova中默认的存在一个default的安全组，可以在里面添加相应的规则。</p>

<blockquote><p>在具体的实现上，底层使用的iptables，由于OVS并不支持iptables规则的tap设备，所以在compute节点使用Linux bridge进行实现。</p></blockquote>

<p>要查看相应的安全组的规则，需要在compute节点上进行查看有三种方式，INPUT（进入），OUTPUT（出去）和FORWARD（转发）。
以INPUT为例，安全组是对应的bridge来说的，为了区分不同的安全组，可以通过查找vm上的tap设备来找到对应的安全组规则，这样就可以实现不同虚机和不同规则的安全组连接。
下面来查找INPUT的iptables规则，可以看到和安全组相关的规则都被重定向到neutron-openvswi-INPUT。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@host42 ~]# iptables --line-numbers -vnL INPUT
</span><span class='line'>Chain INPUT (policy ACCEPT 18860 packets, 26M bytes)
</span><span class='line'>num   pkts bytes target     prot opt in     out     source               destination         
</span><span class='line'>1    8542K 4539M neutron-openvswi-INPUT  all  --  *      *       0.0.0.0/0            0.0.0.0/0           
</span><span class='line'>2        0     0 ACCEPT     udp  --  virbr0 *       0.0.0.0/0            0.0.0.0/0            udp dpt:53
</span><span class='line'>3        0     0 ACCEPT     tcp  --  virbr0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:53
</span><span class='line'>4        0     0 ACCEPT     udp  --  virbr0 *       0.0.0.0/0            0.0.0.0/0            udp dpt:67
</span><span class='line'>5        0     0 ACCEPT     tcp  --  virbr0 *       0.0.0.0/0            0.0.0.0/0            tcp dpt:67</span></code></pre></td></tr></table></div></figure>


<p>继续查看neutron-openvswi-INPUT的iptables规则表，可以看到几个不同的tap设备对应着不同的neutron-openvswi规则，这主要是因为在该计算节点已经创建了几台不同的虚拟，而这tap设备就是与虚机的bridge所对应。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@host42 ~]# iptables --line-numbers -vnL neutron-openvswi-INPUT
</span><span class='line'>Chain neutron-openvswi-INPUT (1 references)
</span><span class='line'>num   pkts bytes target     prot opt in     out     source               destination         
</span><span class='line'>1        0     0 neutron-openvswi-o0920e155-8  all  --  *      *       0.0.0.0/0            0.0.0.0/0            PHYSDEV match --physdev-in tap0920e155-86 --physdev-is-bridged /* Direct incoming traffic from VM to the security group chain. */
</span><span class='line'>2        0     0 neutron-openvswi-o101e9de7-b  all  --  *      *       0.0.0.0/0            0.0.0.0/0            PHYSDEV match --physdev-in tap101e9de7-be --physdev-is-bridged /* Direct incoming traffic from VM to the security group chain. */
</span><span class='line'>3        0     0 neutron-openvswi-o81b5c22c-8  all  --  *      *       0.0.0.0/0            0.0.0.0/0            PHYSDEV match --physdev-in tap81b5c22c-86 --physdev-is-bridged /* Direct incoming traffic from VM to the security group chain. */
</span><span class='line'>4        0     0 neutron-openvswi-oa1c05cb3-9  all  --  *      *       0.0.0.0/0            0.0.0.0/0            PHYSDEV match --physdev-in tapa1c05cb3-90 --physdev-is-bridged /* Direct incoming traffic from VM to the security group chain. */</span></code></pre></td></tr></table></div></figure>


<p>在network01网络创建的host01的hostnameID为11f1d000-615b-4cee-b760-baef886b6637，那么找到所对应的tap设备后，找出其iptables的规则，如下所示</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> [root@host42 11f1d000-615b-4cee-b760-baef886b6637]# iptables --line-numbers -vnL neutron-openvswi-INPUT|grep tapa1c05cb3-90
</span><span class='line'>4        0     0 neutron-openvswi-oa1c05cb3-9  all  --  *      *       0.0.0.0/0            0.0.0.0/0            PHYSDEV match --physdev-in tapa1c05cb3-90 --physdev-is-bridged /* Direct incoming traffic from VM to the security group chain. */</span></code></pre></td></tr></table></div></figure>


<p>可以看出规则被重定向都neutron-openvswi-oa1c05cb3-9，接着查看neutron-openvswi-oa1c05cb3-9的iptables规则，可以看到从虚机发送到DHCP的请求直接通过，而其他的请求则会转到neutron-openvswi-sa1c05cb3-9。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@host42 11f1d000-615b-4cee-b760-baef886b6637]# iptables --line-numbers -vnL neutron-openvswi-oa1c05cb3-9
</span><span class='line'>Chain neutron-openvswi-oa1c05cb3-9 (2 references)
</span><span class='line'>num   pkts bytes target     prot opt in     out     source               destination         
</span><span class='line'>1        2   648 RETURN     udp  --  *      *       0.0.0.0/0            0.0.0.0/0            udp spt:68 udp dpt:67 /* Allow DHCP client traffic. */
</span><span class='line'>2       27  1710 neutron-openvswi-sa1c05cb3-9  all  --  *      *       0.0.0.0/0            0.0.0.0/0           
</span><span class='line'>3        0     0 DROP       udp  --  *      *       0.0.0.0/0            0.0.0.0/0            udp spt:67 udp dpt:68 /* Prevent DHCP Spoofing by VM. */
</span><span class='line'>4        0     0 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED /* Direct packets associated with a known session to the RETURN chain. */
</span><span class='line'>5       27  1710 RETURN     all  --  *      *       0.0.0.0/0            0.0.0.0/0           
</span><span class='line'>6        0     0 DROP       all  --  *      *       0.0.0.0/0            0.0.0.0/0            state INVALID /* Drop packets that appear related to an existing connection (e.g. TCP ACK/FIN) but do not have an entry in conntrack. */
</span><span class='line'>7        0     0 neutron-openvswi-sg-fallback  all  --  *      *       0.0.0.0/0            0.0.0.0/0            /* Send unmatched traffic to the fallback chain. */</span></code></pre></td></tr></table></div></figure>


<p>接着查看neutron-openvswi-sa1c05cb3-9的规则，这条chain主要检查从vm发出来的网包，是否是openstack所分配的IP和MAC，如果不匹配，则禁止通过。这将防止利用vm上进行一些伪装地址的攻击。</p>

<p>?????????????</p>

<p>OUTPUT和FORWARD的规则查看方法和INPUT的类似，可以依据上述方法进行安全组的学习</p>

<h2>2、计算节点的流量转发机制</h2>

<h2>3、控制节点的流量转发机制</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多机环境下虚机网络实现机制（一）]]></title>
    <link href="http://chyufly.github.io/blog/2016/07/11/understanding-neutron-vm-creating/"/>
    <updated>2016-07-11T22:47:34+08:00</updated>
    <id>http://chyufly.github.io/blog/2016/07/11/understanding-neutron-vm-creating</id>
    <content type="html"><![CDATA[<h1>&mdash;  <strong><em>虚机的网络配置详解</em></strong></h1>

<hr />

<p>该部分主要介绍在多机环境下，虚拟机的网络是如何创建和配置的，具体来说就是各个节点之间的相互配合，包括compute node的nova compute的port绑定，以及controller node的neutron server的调用以及实现过程。</p>

<h2></h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[training-ha-openstack]]></title>
    <link href="http://chyufly.github.io/blog/2016/05/21/training-ha-openstack/"/>
    <updated>2016-05-21T16:27:58+08:00</updated>
    <id>http://chyufly.github.io/blog/2016/05/21/training-ha-openstack</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[US专题(二)-HA技术介绍]]></title>
    <link href="http://chyufly.github.io/blog/2016/05/21/training-ha-introduction/"/>
    <updated>2016-05-21T16:19:10+08:00</updated>
    <id>http://chyufly.github.io/blog/2016/05/21/training-ha-introduction</id>
    <content type="html"><![CDATA[<h2><strong>HA(High Availability)的定义</strong></h2>

<h4><strong>可用性</strong></h4>

<p>提供在本地系统的单个组件故障情况下，能够继续访问应用的能力，最好的可用性就是，如果一台机器宕机了，使用服务的用户完全感觉不到</p>

<h4><strong>故障恢复</strong></h4>

<p>如果出现宕机，在该机器上运行的服务肯定得做故障切换(failover)，切换主要分为两个维度：</p>

<ul>
<li>RTO(Recovery Time Objective):主要是指服务恢复的时间</li>
<li>RPO(Recovery Point Objective)：主要是指切换时向前恢复的数据的时间长度，RPO=1天意味着恢复时使用一天前的数据，那么一天之内的数据就丢失了。</li>
</ul>


<h5><em>补充概念</em></h5>

<ul>
<li>Active/Passive:主要包括一台活动提供服务的服务器和一台待命不对外提供服务的服务器，一般在讲failover就是属于这个，也是cluster HA基本款。</li>
<li>Active/Active:两台（或N台）同时运作，每台机器可以跑一个运行的实例，当一台机器出现宕机时，就会将运行的实例切换到另外一台机器上去，那么另外一台机器就会运行两个实例，AA模式保证了两台机器资源都被利用。</li>
</ul>


<h2><strong>HA(High Availability)的实现</strong></h2>

<h3><strong>（一）冗余</strong></h3>

<h4><strong>硬件</strong></h4>

<ul>
<li>电源：采用双路供电</li>
<li><p>磁盘：可以分为RAID0、RAID1、RAID5等</p>

<ul>
<li><strong>RAID0:</strong>又称为stripe或者striping，代表了RAID级别中最高的存储性能，原理就是把连续的数据分散到多个磁盘上进行存取，这样，系统有数据请求就可以被多个磁盘并行的执行，每个磁盘执行属于它自己的那部分数据请求，这样可以充分利用总线的带宽。</li>
<li><strong>RAID1:</strong>通过磁盘数据镜像实现数据冗余，在成对的独立磁盘上产生互为备份的数据，当原始数据繁忙时，可直接从镜像拷贝中读取数据，这样就提高了读取性能，并保证了数据的可靠性和安全性。当一个磁盘失效时，系统就可以自动切换到镜像磁盘上读写。</li>
<li>RAID5:可以理解为RAID0和RAID1的折中方案，可以为系统提供数据安全保障，但保障程度要比mirror低，而磁盘空间利用率要比mirror高。</li>
<li>RAID10:主要是一个RAID0和RAID1的结合，利用奇偶校验实现条带集镜像，继承了RAID0的快速和RAID1的安全</li>
</ul>
</li>
<li><p>网卡：（bonding，双路）在linux服务器上可以利用bonding技术，将多个网卡当做一个网卡使用，不仅提高了带宽而且提高了可用性。</p></li>
<li><p>交换机：LACP、VRRP</p></li>
</ul>


<blockquote><ul>
<li><p><em>LACP(Link Aggregration Control Protocol，链路汇聚控制协议)：</em>是一种实现链路动态汇聚的协议，LACP协议通过<em>LACPDU（LACP Data Unit，链路汇聚控制协议数据单元）</em>与对端交互信息。当启用某一端口的LACP协议后，该端口将发送LACPDU向对端通告自己的系统优先级，系统MAC地址，端口优先级，端口号和操作Key。对端接受到这些信息后，将这些信息与其他端口所保存的信息比较以选择能够汇聚的端口，从而双发可以对端口加入或退出某个动态汇聚组达成一致。</p></li>
<li><p><em>虚拟路由冗余协议(Virtual Router Redundancy Protocol，简称VRRP)</em>是由IETF提出的解决局域网中配置静态网关出现单点失效现象的路由协议，VRRP广泛应用在边缘网络中，它的设计目标是支持特定情况下IP数据流量失败转移不会引起混乱，允许主机使用单路由器，以及及时在实际第一跳路由器使用失败的情形下仍能够维护路由器间的连通性。</p></li>
</ul>
</blockquote>

<h4><strong>软件</strong></h4>

<ul>
<li>协议:HTTP、广播</li>
<li>负载均衡：LVS、haproxy、nginx</li>
</ul>


<blockquote><p><strong><em>LVS</em></strong> 采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序。为此，在设计时需要考虑系统的透明性、可伸缩性、高可用性和易管理性。</p>

<p><strong><em>Nginx</em></strong> 是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。</p>

<p><strong><em>HAProxy</em></strong> 提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。</p></blockquote>

<ul>
<li>集群:主主、主备；同步，异步</li>
</ul>


<h3><strong>（二）校验</strong></h3>

<ul>
<li>checksum(TCP校验和)：是一个端到端的校验和，由发送端计算，然后由接收端验证。</li>
<li>CRC（Cyclic redundancy check循环冗余校验）：主要用来检验数据传输和保存后可能出现的错误，生成的数字在传输的过程或者存储之前计算出来并且附加到数据的后面。</li>
<li>重传</li>
</ul>


<h3><strong>（三）综合</strong></h3>

<ul>
<li>校验+冗余</li>
</ul>


<h3><strong>（四）Failover</strong></h3>

<blockquote><p> 又称故障切换，指系统中其中一项设备或服务失效而无法运作时，另一项设备或服务即可自动接手原失效系统所执行的工作。</p></blockquote>

<p><em>为了实现自动的故障切换，通常需要在冗余的组件之间启用心跳机制，以相互检测彼此的状态，在检测到故障时自动进行切换</em></p>

<ul>
<li>监控</li>
<li>切换</li>
</ul>


<h3><strong>（五）相关软件</strong></h3>

<ul>
<li>keepalived</li>
<li>pacemaker</li>
<li>heartbeat + DRBD(AP实现方式)</li>
</ul>


<blockquote><p>DRBD(Distributed Replicated Block Device)是一个用软件实现的、无共享的、服务器之间镜像块设备内容的存储复制解决方案。号称“网络RAID”。通过网络通信来同步镜像整个设备，当数据写入本地的DRBD设备上的文件系统时，数据会同时被发送到网络中的另外一台主机之上，并以完全相同的形式记录在一个文件系统中。本地节点（主机）与远程节点（主机）的数据可以保证实时的同步，并保证IO的一致性。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[US专题(一)-RabbitMQ]]></title>
    <link href="http://chyufly.github.io/blog/2016/05/18/training-rabbitmq/"/>
    <updated>2016-05-18T23:12:23+08:00</updated>
    <id>http://chyufly.github.io/blog/2016/05/18/training-rabbitmq</id>
    <content type="html"><![CDATA[<blockquote><p>说明：RabbitMQ是一种消息中间件，并以其高效的集群部署和HA得到广泛的应用</p></blockquote>

<h3><strong>有关queue_declare的总结</strong></h3>

<p>在publish/subscribe这种方式中，如果将queue中定义的prefetch_count设置为1，那么创建的queue就会认为只会提取一个消息。这种场景适合于希望一段时间消息被固定在一个消费者上。如果不设置这个参数，可能在product产生多个消息发出后，一个消费者就可能从RabbitMQ中取所有的消息，而不让其他消费者对消息进行消费。</p>

<blockquote><p>这里需要注意的一个问题就是，一个消费者只能绑定一个queue，一个exchange可以定义多个queue。而多个消费者可能就是在轮询的接受信息。</p></blockquote>

<h3><strong>RabbitMQ的HA</strong></h3>

<p>这个HA的特性是RabbitMQ的特点之一，所以对开发者来说就显得比较重要。
主要包括两部分：</p>

<ul>
<li>服务可靠：这里的服务可靠性主要是指RabbitMQ的集群，保证元数据的HA</li>
</ul>


<blockquote><p>rabbitmq cluster 实现vhost&amp;exchange&amp;queue&amp;binding等元数据的同步</p></blockquote>

<ul>
<li>数据可靠：这里的数据可靠性主要是针对mirror queue，镜像队列可以将消息复制到集群的多个节点上去，这样如果出现某一个节点down的情况，也可以保证整个集群式高可用的。</li>
</ul>


<blockquote><p>mirror queue 实现队列中消息的同步</p></blockquote>

<h4><strong>如何实现RabbitMQ的高可用性</strong></h4>

<h5>可靠的消息传递</h5>

<ul>
<li><p><strong>Pubilsher confirm</strong></p></li>
<li><p><strong>Delivery Acknowledge</strong></p></li>
<li><p><strong>故障时消息不会消失：多个副本；写磁盘</strong></p></li>
</ul>


<h5>消息队列服务HA</h5>

<ul>
<li><p><strong>避免单点故障</strong></p></li>
<li><p><strong>可扩展的消息集群</strong></p></li>
</ul>


<h5>实现高可用的集群</h5>

<ul>
<li><p><strong>rabbitmq cluster</strong></p></li>
<li><p><strong>mirror queue</strong></p></li>
<li><p><strong>共享存储</strong></p></li>
<li><p><strong>pacemaker：实现服务监控和故障转移</strong></p></li>
</ul>


<h4>比较好的参考资料：</h4>

<p><a href="https://www.rabbitmq.com/ha.html">https://www.rabbitmq.com/ha.html</a></p>

<p><a href="https://www.rabbitmq.com/clustaering.html">https://www.rabbitmq.com/clustaering.html</a></p>

<p><a href="http://www.rabbitmq.com/pacemaker.html">http://www.rabbitmq.com/pacemaker.html</a></p>

<p><a href="http://pdf.th7.cn/down/files/1312/RabbitMQ%20in%20Action.pdf">http://pdf.th7.cn/down/files/1312/RabbitMQ%20in%20Action.pdf</a></p>

<p><a href="http://my.oschina.net/moooofly/blog/284542">http://my.oschina.net/moooofly/blog/284542</a></p>

<p><a href="http://my.oschina.net/hncscwc/blog/186350">http://my.oschina.net/hncscwc/blog/186350</a></p>

<h3><strong>RabbitMQ troubleshooting介绍</strong></h3>

<h4><strong>排错工具</strong></h4>

<h5>通过监控查看rabbitmq的状态是否正常</h5>

<ul>
<li><strong>rabbitmqctl &amp; rabbitmqadmin</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>启动或终止rabbitmq
</span><span class='line'>用户、权限、集群、policy管理
</span><span class='line'>查看队列、exchange、queue、channel、consumer、状态...</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>rabbitmq manangement plugin</strong>

<h5>查看日志，确定具体的错误</h5></li>
<li><strong>启动日志：/var/log/rabbitmq/startup_{log,err} </strong></li>
<li><strong>关闭日志：/var/log/rabbitmq/shutdown_{log,err} </strong></li>
<li><strong>运行日志：/var/log/rabbitmq/rabbit@<host>.log</strong></li>
</ul>


<h4><strong>排错思路</strong></h4>

<ul>
<li>rabbitmq server 本身的问题</li>
<li>应用程序的问题</li>
</ul>


<h4><strong>常见故障检测</strong></h4>

<ul>
<li>rabbitmq server启动失败</li>
<li>rabbitmq 网络分区</li>
<li>rabbitmq 不接受消息</li>
<li>rabbitmq 消息堆积</li>
</ul>


<h4><strong>rabbitmq server启动失败</strong></h4>

<ul>
<li>cookie不一致</li>
<li>hostname发生了变化</li>
<li>集群：连接不上其他节点</li>
</ul>


<h4><strong>网络分区</strong></h4>

<ul>
<li>出现网络分区的情况下，各自独立提供服务，但是不再同步消息</li>
<li>net_ticktime：默认60-120秒；这个时间段内节点之间会发送4个tick包</li>
<li>mnesia不一致：网络中断，不能通讯</li>
</ul>


<h4><strong>rabbitmq不接受消息</strong></h4>

<h5>rabbitmq内部发生了阻塞</h5>

<ul>
<li><strong>flow control:内存、磁盘</strong></li>
<li><strong>消息堆积</strong>

<h5>连接异常导致空等</h5></li>
</ul>


<h4><strong>rabbitmq消息堆积</strong></h4>

<p>在出现网络连接异常时，client端没有重新建立连接，一直等待，不消费消息</p>

<h4><strong>不能检测网络故障并自动重连</strong></h4>

<ul>
<li>RabbitMQ heartbeat</li>
<li>tcp keep alive</li>
<li>net.ipv4.tcp_retries2</li>
</ul>


<h4><strong>参考资料</strong></h4>

<p><a href="https://www.rabbitmq.com/management.html">https://www.rabbitmq.com/management.html</a></p>

<p><a href="https://www.rabbitmq.com/nettick.html">https://www.rabbitmq.com/nettick.html</a></p>

<p><a href="http://stackoverflow.com/questions/5907527/application-control-of-tcp-retransmission-on-linux">http://stackoverflow.com/questions/5907527/application-control-of-tcp-retransmission-on-linux</a></p>

<h3><strong>performance tuning for RabbitMQ</strong></h3>

<h4><strong>trade-off</strong></h4>

<ul>
<li><p>对性能的需求：1k/s,10k/s,100k/s</p></li>
<li><p>对消息持久性的需求</p></li>
<li><p>通信模式：pub-sub,fanout,topic</p></li>
<li><p>集群的规模</p></li>
</ul>


<h4><strong>性能调优</strong></h4>

<ul>
<li><p>放开文件描述符的限制</p></li>
<li><p>提高内存的占用量</p></li>
<li><p>提高磁盘读写性能</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[neutron-source_code-structure]]></title>
    <link href="http://chyufly.github.io/blog/2016/04/18/neutron-source-code-structure/"/>
    <updated>2016-04-18T10:29:25+08:00</updated>
    <id>http://chyufly.github.io/blog/2016/04/18/neutron-source-code-structure</id>
    <content type="html"><![CDATA[<h2>OpenStack源码分析-neutron(一)</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RabbitMQ概念和应用详解]]></title>
    <link href="http://chyufly.github.io/blog/2016/04/13/rabbitmq-introduction/"/>
    <updated>2016-04-13T10:46:01+08:00</updated>
    <id>http://chyufly.github.io/blog/2016/04/13/rabbitmq-introduction</id>
    <content type="html"><![CDATA[<hr />

<h2>RabbitMQ概述</h2>

<h3>RabbitMQ可以做什么？</h3>

<p>RabbitMQ是实现AMQP(高级消息队列协议)的消息中间件的一种，可用于在分布式系统中存储转发消息，主要有以下的技术亮点：</p>

<ul>
<li>可靠性</li>
<li>灵活的路由</li>
<li>集群部署</li>
<li>高可用的队列消息</li>
<li>可视化的管理工具</li>
</ul>


<p>RabbitMQ主要用于系统间的双向解耦，当生产者（productor）产生大量的数据时，消费者（consumer）无法快速的消费信息，那么就需要一个类似于中间件的代理服务器，用来处理和保存这些数据，RabbitMQ就扮演了这个角色。</p>

<h3>如何使用RabbitMQ</h3>

<ul>
<li>Erlang语言包</li>
<li>RabbitMQ安装包</li>
</ul>


<h3>基本概念</h3>

<h4>1.Broker</h4>

<p> 用来处理数据的消息队列服务器实体</p>

<h4>2.虚拟主机(vhost)</h4>

<p> 由RabbitMQ服务器创建的虚拟消息主机，拥有自己的权限机制，一个broker里可以开设多个vhost，用于不同用户的权限隔离，vhost之间是也完全隔离的。</p>

<h4>3.生产者(productor)</h4>

<p> 产生用于消息通信的数据</p>

<h4>4.信道(channel)</h4>

<p>消息通道，在AMQP中可以建立多个channel，每个channel代表一个会话任务。</p>

<h4>5.交换机(exchange)</h4>

<p>(1)接受消息，转发消息到绑定的队列，总共有四种类型的交换器：direct，fanout，topic，headers。</p>

<ul>
<li><strong>direct：</strong>转发消息到routing-key指定的队列</li>
</ul>


<p><img src="http://chyufly.github.io/images/direct-exchange.png"></p>

<ul>
<li><p><strong>fanout：</strong>转发消息到所有绑定的队列，类似于一种广播发送的方式。</p></li>
<li><p><strong>topic：</strong>按照规则转发消息，这种规则多为模式匹配，也显得更加灵活</p></li>
</ul>


<p><img src="http://chyufly.github.io/images/topic-exchange.png"></p>

<p>(2).交换器在RabbitMQ中是一个存在的实体，不能改变，如有需要只能删除重建。</p>

<p>(3).topic类型的交换器利用匹配规则分析消息的routing-key属性。</p>

<p>(4).属性</p>

<ul>
<li><strong>持久性：</strong>声明时durable属性为true</li>
<li><strong>自动删除：</strong>绑定的queue删除也跟着删除</li>
<li><strong>惰性：</strong>不会自动创建</li>
</ul>


<h4>6.队列(queue)</h4>

<p>(1).队列是RabbitMQ的内部对象，存储消息</p>

<p>(2).可以动态的增加消费者，队列将接受到的消息以轮询(round-robin)的方式均匀的分配给多个消费者</p>

<p>(3).队列的属性</p>

<ul>
<li><strong>持久性：</strong>如果启用，队列将会在server重启之前有效</li>
<li><strong>自动删除：</strong>消费者停止使用之后就会自动删除</li>
<li><strong>惰性：</strong>不会自动创建</li>
<li><strong>排他性：</strong>如果启用，队列只能被声明它的消费者使用。</li>
</ul>


<h4>7.两个key</h4>

<ul>
<li><strong>routing-key:</strong>消息不能直接发到queues，需要先发送到exchanges，routing-key指定queues名称，exchanges通过routing-key来识别与之绑定的queues</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">channel</span><span class="o">.</span><span class="n">queue_publish</span><span class="p">(</span><span class="n">exchange</span><span class="o">=</span><span class="n">exchange_name</span><span class="p">,</span>
</span><span class='line'>                     <span class="n">routing</span><span class="o">-</span><span class="n">key</span><span class="o">=</span><span class="s">&quot;rabbitmq&quot;</span><span class="p">,</span>
</span><span class='line'>                     <span class="n">body</span><span class="o">=</span><span class="s">&quot;openstack&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>binding-key:</strong>主要是用来表示exchanges和queues之间的关系，为了区别queue_publish的routing-key，就称作binding-key。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">channel</span><span class="o">.</span><span class="n">queue_bind</span><span class="p">(</span><span class="n">exchange</span><span class="o">=</span><span class="n">exchange_name</span><span class="p">,</span>
</span><span class='line'>                  <span class="n">queue</span><span class="o">=</span><span class="n">queue_name</span><span class="p">,</span>
</span><span class='line'>                  <span class="n">routing</span><span class="o">-</span><span class="n">key</span><span class="o">=</span><span class="s">&quot;rabbitmq&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>8.绑定(binding)</h4>

<p>表示交换机和队列之间的关系，在进行绑定时，带有一个额外的参数<em>binding-key</em>，来和<em>routing-key</em>相匹配。</p>

<h4>9.消费者(consumer)</h4>

<p>监听消息队列来进行消息数据的读取</p>

<h4>10.高可用性(HA)</h4>

<p>(1).在consumer处理完消息后，会发送消息ACK，通知通知RabbitMQ消息已被处理，可以从内存删除。如果消费者因宕机或链接失败等原因没有发送ACK，则RabbitMQ会将消息重新发送给其他监听在队列的下一个消费者。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">channel</span><span class="o">.</span><span class="n">basicConsume</span><span class="p">(</span><span class="n">queuename</span><span class="p">,</span> <span class="n">noAck</span><span class="o">=</span><span class="n">false</span><span class="p">,</span> <span class="n">consumer</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>(2).消息和队列的持久化</p>

<p>(3).镜像队列，实现不同节点之间的元数据和消息同步</p>

<h1><em>RabbitMQ在OpenStack中的应用</em></h1>

<h3><strong>RPC之neutron专题</strong></h3>

<p>基于RabbitMQ的RPC消息通信是neutron中跨模块进行方法调用的很重要的一种方式，根据上面的描述，要组成一个完整的RPC通信结构，需要信息的生产者和消费者。</p>

<ul>
<li><strong>client端：</strong>用于产生rpc消息。</li>
<li><strong>server端：</strong>用于监听消息数据并进行相应的处理。</li>
</ul>


<h4>1.neutron-agent中的RPC</h4>

<p>在dhcp_agent、l3_agent、metadata_agent，metering_agent的main函数中都存在一段创建一个rpc服务端的代码，下面以dhcp_agent为例。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
</span><span class='line'>    <span class="n">register_options</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="p">)</span>
</span><span class='line'>    <span class="n">common_config</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
</span><span class='line'>    <span class="n">config</span><span class="o">.</span><span class="n">setup_logging</span><span class="p">()</span>
</span><span class='line'>    <span class="n">server</span> <span class="o">=</span> <span class="n">neutron_service</span><span class="o">.</span><span class="n">Service</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
</span><span class='line'>        <span class="n">binary</span><span class="o">=</span><span class="s">&#39;neutron-dhcp-agent&#39;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">topic</span><span class="o">=</span><span class="n">topics</span><span class="o">.</span><span class="n">DHCP_AGENT</span><span class="p">,</span>
</span><span class='line'>        <span class="n">report_interval</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">AGENT</span><span class="o">.</span><span class="n">report_interval</span><span class="p">,</span>
</span><span class='line'>        <span class="n">manager</span><span class="o">=</span><span class="s">&#39;neutron.agent.dhcp.agent.DhcpAgentWithStateReport&#39;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">service</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="p">,</span> <span class="n">server</span><span class="p">)</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>最核心的，也是跟rpc相关的部分包括两部分，首先是创建rpc服务端。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">server</span> <span class="o">=</span> <span class="n">neutron_service</span><span class="o">.</span><span class="n">Service</span><span class="o">.</span><span class="n">create</span><span class="p">(</span>
</span><span class='line'>    <span class="n">binary</span><span class="o">=</span><span class="s">&#39;neutron-dhcp-agent&#39;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">topic</span><span class="o">=</span><span class="n">topics</span><span class="o">.</span><span class="n">DHCP_AGENT</span><span class="p">,</span>
</span><span class='line'>    <span class="n">report_interval</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">AGENT</span><span class="o">.</span><span class="n">report_interval</span><span class="p">,</span>
</span><span class='line'>    <span class="n">manager</span><span class="o">=</span><span class="s">&#39;neutron.agent.dhcp.agent.DhcpAgentWithStateReport&#39;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>该代码实际上创建了一个rpc服务端，监听指定的topic并运行manager上的tasks。</p>

<p>create()方法返回一个neutron.service.Service对象，neutron.service.Service继承自neutron.common.rpc.Service类。</p>

<p>首先看neutron.common.rpc.Service类，该类定义了start方法，该方法主要完成两件事情：一件事情是将manager添加到endpoints中；一件是创建rpc的consumer，分别监听topic的队列消息。</p>

<p>而在neutron.service.Service类中，初始化中生成了一个manager实例（即neutron.agent.dhcp_agent.DhcpAgentWithStateReport）；并为start方法添加了周期性执行report_state方法和periodic_tasks方法。report_state方法没有具体实现，periodic_tasks方法则调用manager的periodic_tasks方法。</p>

<p>manager实例（即neutron.agent.dhcp_agent.DhcpAgentWithStateReport）在初始化的时候首先创建一个rpc的client端，通过代码</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'> <span class="bp">self</span><span class="o">.</span><span class="n">state_rpc</span> <span class="o">=</span> <span class="n">agent_rpc</span><span class="o">.</span><span class="n">PluginReportStateAPI</span><span class="p">(</span><span class="n">topics</span><span class="o">.</span><span class="n">PLUGIN</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>该client端实际上定义了report_state方法，可以状态以rpc消息的方式发送给plugin。</p>

<p>manager在初始化后，还会指定周期性运行_report_state方法，实际上就是调用client端的report_state方法。</p>

<p>至此，对rpc服务端的创建算是完成了，之后执行代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">service</span><span class="o">.</span><span class="n">launch</span><span class="p">(</span><span class="n">server</span><span class="p">)</span><span class="o">.</span><span class="n">wait</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>service.launch(server)方法首先会将server放到协程组中，并调用server的start方法来启动server。</p>

<p> <img src="http://chyufly.github.io/images/neutron.PNG"></p>

<h4>2.neutron-plugin中的RPC</h4>

<p>主要对ML2Plugin进行分析，包括两个类：RpcCallbacks和AgentNotifierApi。</p>

<ul>
<li><p><strong>RpcCallbacks：</strong>负责当agent往plugin发出rpc请求时候，plugin实现请求的相关动作，除了继承自父类（dhcp rpc、dvr rpc、sg_db rpc和tunnel rpc）中的方法，还包括get_port_from_device、get_device_details、get_devices_details_list、update_device_down、update_device_up、get_dvr_mac_address_by_host、get_compute_ports_on_host_by_subnet、get_subnet_for_dvr等方法。</p></li>
<li><p><strong>AgentNotifierApi：</strong>负责当plugin往agent发出rpc请求（plugin通知agent）的时候，plugin端的方法。</p></li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">start_rpc_listeners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>    <span class="sd">&quot;&quot;&quot;RpcCallbacks中实现的方法：Start the RPC loop to let the plugin communicate with agents.&quot;&quot;&quot;</span>
</span><span class='line'>    <span class="bp">self</span><span class="o">.</span><span class="n">_setup_rpc</span><span class="p">()</span>
</span><span class='line'>    <span class="bp">self</span><span class="o">.</span><span class="n">topic</span> <span class="o">=</span> <span class="n">topics</span><span class="o">.</span><span class="n">PLUGIN</span>
</span><span class='line'>    <span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">n_rpc</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span><span class="n">new</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</span><span class='line'>    <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">create_consumer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">,</span> <span class="n">fanout</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">consume_in_threads</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建一个通知rpc的客户端，用于向OVS的agent发出通知。所有plugin都需要有这样一个发出通知消息的客户端，创建了一个OVS agent的通知rpc客户端。之后，创建两个跟service agent相关的consumer，分别监听topics.PLUGIN</p>

<p> <img src="http://chyufly.github.io/images/RPC_Neutron.PNG"></p>

<p>ovs_neutron_agent也会创建RPC的consumer，用来监听topics.UPDATE、topics.DELETE等操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">setup_rpc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">agent_id</span> <span class="o">=</span> <span class="s">&#39;ovs-agent-</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">host</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">topic</span> <span class="o">=</span> <span class="n">topics</span><span class="o">.</span><span class="n">AGENT</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">plugin_rpc</span> <span class="o">=</span> <span class="n">OVSPluginApi</span><span class="p">(</span><span class="n">topics</span><span class="o">.</span><span class="n">PLUGIN</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">sg_plugin_rpc</span> <span class="o">=</span> <span class="n">sg_rpc</span><span class="o">.</span><span class="n">SecurityGroupServerRpcApi</span><span class="p">(</span><span class="n">topics</span><span class="o">.</span><span class="n">PLUGIN</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">dvr_plugin_rpc</span> <span class="o">=</span> <span class="n">dvr_rpc</span><span class="o">.</span><span class="n">DVRServerRpcApi</span><span class="p">(</span><span class="n">topics</span><span class="o">.</span><span class="n">PLUGIN</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">state_rpc</span> <span class="o">=</span> <span class="n">agent_rpc</span><span class="o">.</span><span class="n">PluginReportStateAPI</span><span class="p">(</span><span class="n">topics</span><span class="o">.</span><span class="n">PLUGIN</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c"># RPC network init</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">context</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">get_admin_context_without_session</span><span class="p">()</span>
</span><span class='line'>        <span class="c"># Handle updates from service</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">]</span>
</span><span class='line'>        <span class="c"># Define the listening consumers for the agent</span>
</span><span class='line'>        <span class="n">consumers</span> <span class="o">=</span> <span class="p">[[</span><span class="n">topics</span><span class="o">.</span><span class="n">PORT</span><span class="p">,</span> <span class="n">topics</span><span class="o">.</span><span class="n">UPDATE</span><span class="p">],</span>
</span><span class='line'>                     <span class="p">[</span><span class="n">topics</span><span class="o">.</span><span class="n">PORT</span><span class="p">,</span> <span class="n">topics</span><span class="o">.</span><span class="n">DELETE</span><span class="p">],</span>
</span><span class='line'>                     <span class="p">[</span><span class="n">constants</span><span class="o">.</span><span class="n">TUNNEL</span><span class="p">,</span> <span class="n">topics</span><span class="o">.</span><span class="n">UPDATE</span><span class="p">],</span>
</span><span class='line'>                     <span class="p">[</span><span class="n">constants</span><span class="o">.</span><span class="n">TUNNEL</span><span class="p">,</span> <span class="n">topics</span><span class="o">.</span><span class="n">DELETE</span><span class="p">],</span>
</span><span class='line'>                     <span class="p">[</span><span class="n">topics</span><span class="o">.</span><span class="n">SECURITY_GROUP</span><span class="p">,</span> <span class="n">topics</span><span class="o">.</span><span class="n">UPDATE</span><span class="p">],</span>
</span><span class='line'>                     <span class="p">[</span><span class="n">topics</span><span class="o">.</span><span class="n">DVR</span><span class="p">,</span> <span class="n">topics</span><span class="o">.</span><span class="n">UPDATE</span><span class="p">],</span>
</span><span class='line'>                     <span class="p">[</span><span class="n">topics</span><span class="o">.</span><span class="n">NETWORK</span><span class="p">,</span> <span class="n">topics</span><span class="o">.</span><span class="n">UPDATE</span><span class="p">]]</span>
</span></code></pre></td></tr></table></div></figure>


<h4>3.neutron-server中的RPC</h4>

<p>这个rpc服务端主要通过neutron.server中主函数中代码执行</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">neutron_rpc</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="n">serve_rpc</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>方法的实现代码(目录：neutron/neutron/service.py)如下</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">serve_rpc</span><span class="p">():</span>
</span><span class='line'>    <span class="n">plugin</span> <span class="o">=</span> <span class="n">manager</span><span class="o">.</span><span class="n">NeutronManager</span><span class="o">.</span><span class="n">get_plugin</span><span class="p">()</span>
</span><span class='line'>    <span class="n">service_plugins</span> <span class="o">=</span> <span class="p">(</span>
</span><span class='line'>        <span class="n">manager</span><span class="o">.</span><span class="n">NeutronManager</span><span class="o">.</span><span class="n">get_service_plugins</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">rpc_workers</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
</span><span class='line'>        <span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">set_override</span><span class="p">(</span><span class="s">&#39;rpc_workers&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="ow">not</span> <span class="n">plugin</span><span class="o">.</span><span class="n">rpc_workers_supported</span><span class="p">():</span>
</span><span class='line'>        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Active plugin doesn&#39;t implement start_rpc_listeners&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">rpc_workers</span><span class="p">:</span>
</span><span class='line'>            <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">_LE</span><span class="p">(</span><span class="s">&quot;&#39;rpc_workers = </span><span class="si">%d</span><span class="s">&#39; ignored because &quot;</span>
</span><span class='line'>                          <span class="s">&quot;start_rpc_listeners is not implemented.&quot;</span><span class="p">),</span>
</span><span class='line'>                      <span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">rpc_workers</span><span class="p">)</span>
</span><span class='line'>        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">try</span><span class="p">:</span>
</span><span class='line'>        <span class="n">rpc</span> <span class="o">=</span> <span class="n">RpcWorker</span><span class="p">(</span><span class="n">service_plugins</span><span class="p">)</span>
</span><span class='line'>        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;using launcher for rpc, workers=</span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">rpc_workers</span><span class="p">)</span>
</span><span class='line'>        <span class="n">session</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
</span><span class='line'>        <span class="n">launcher</span> <span class="o">=</span> <span class="n">common_service</span><span class="o">.</span><span class="n">ProcessLauncher</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="p">,</span> <span class="n">wait_interval</span><span class="o">=</span><span class="mf">1.0</span><span class="p">)</span>
</span><span class='line'>        <span class="n">launcher</span><span class="o">.</span><span class="n">launch_service</span><span class="p">(</span><span class="n">rpc</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">rpc_workers</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">rpc_state_report_workers</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span>
</span><span class='line'>            <span class="n">plugin</span><span class="o">.</span><span class="n">rpc_state_report_workers_supported</span><span class="p">()):</span>
</span><span class='line'>            <span class="n">rpc_state_rep</span> <span class="o">=</span> <span class="n">RpcReportsWorker</span><span class="p">([</span><span class="n">plugin</span><span class="p">])</span>
</span><span class='line'>            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&#39;using launcher for state reports rpc, workers=</span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span>
</span><span class='line'>                      <span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">rpc_state_report_workers</span><span class="p">)</span>
</span><span class='line'>            <span class="n">launcher</span><span class="o">.</span><span class="n">launch_service</span><span class="p">(</span>
</span><span class='line'>                <span class="n">rpc_state_rep</span><span class="p">,</span> <span class="n">workers</span><span class="o">=</span><span class="n">cfg</span><span class="o">.</span><span class="n">CONF</span><span class="o">.</span><span class="n">rpc_state_report_workers</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">launcher</span>
</span><span class='line'>    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
</span><span class='line'>        <span class="k">with</span> <span class="n">excutils</span><span class="o">.</span><span class="n">save_and_reraise_exception</span><span class="p">():</span>
</span><span class='line'>            <span class="n">LOG</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">_LE</span><span class="p">(</span><span class="s">&#39;Unrecoverable error: please check log for &#39;</span>
</span><span class='line'>                              <span class="s">&#39;details.&#39;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，RpcWorker(plugin)主要通过调用plugin的方法来创建rpc服务端,最重要的工作是调用plugin的start_rpc_listeners来监听消息队列：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="bp">self</span><span class="o">.</span><span class="n">_servers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_plugin</span><span class="o">.</span><span class="n">start_rpc_listeners</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>该方法在大多数plugin中并未被实现，目前ml2支持该方法。</p>

<p>在neutron.plugin.ml2.plugin.ML2Plugin类中，该方法创建了一个topic为topics.PLUGIN的消费rpc。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">start_rpc_listeners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">rpc</span><span class="o">.</span><span class="n">RpcCallbacks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notifier</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_manager</span><span class="p">),</span>
</span><span class='line'>                          <span class="n">agents_db</span><span class="o">.</span><span class="n">AgentExtRpcCallback</span><span class="p">()]</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">topic</span> <span class="o">=</span> <span class="n">topics</span><span class="o">.</span><span class="n">PLUGIN</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span> <span class="o">=</span> <span class="n">n_rpc</span><span class="o">.</span><span class="n">create_connection</span><span class="p">(</span><span class="n">new</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</span><span class='line'>        <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">create_consumer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endpoints</span><span class="p">,</span>
</span><span class='line'>                                  <span class="n">fanout</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn</span><span class="o">.</span><span class="n">consume_in_threads</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<h3><strong>RPC之nova专题</strong></h3>

<p>在Openstack中，每一个Nova服务初始化时会创建两个队列，一个名为“NODE-TYPE.NODE-ID”，另一个名为“NODE-TYPE”，NODE-TYPE是指服务的类型，NODE-ID指节点名称。</p>

<p><img src="http://chyufly.github.io/images/RPC_Nova.png"></p>

<h4>1.nova中实现exchange的种类</h4>

<ul>
<li><strong>direct:</strong>初始化中，各个模块对每一条系统消息自动生成多个队列放入RabbitMQ服务器中，队列中绑定的binding-key要与routing-key匹配</li>
<li><strong>topic:</strong>各个模块也会自动生成两个队列放入RabbitMQ服务器中。</li>
</ul>


<h4>2.nova中调用RPC的方式</h4>

<ul>
<li><strong>RPC.CALL:</strong>用于请求和响应方式</li>
<li><strong>RPC.CAST:</strong>只是提供单向请求</li>
</ul>


<h4>3.nova中模块的逻辑功能</h4>

<ul>
<li><strong>Invoker:</strong>向消息队列中发送系统请求信息，如Nova-API和Nova-Scheduler，通过RPC.CALL和RPC.CAST两个进程发送系统请求消息。</li>
<li><strong>Worker:</strong>从消息队列中获取Invoker模块发送的系统请求消息以及向Invoker模块回复系统响应消息，如Nova-Compute、Nova-Volume和Nova-Network，对RPC.CALL做出响应。</li>
</ul>


<h4>4.nova中的exchange domain</h4>

<ul>
<li><p><strong>direct exchange domain:</strong> Topic消息生产者（Nova-API或者Nova-Scheduler）与Topic交换器生成逻辑连接，通过PRC.CALL或者RPC.CAST进程将系统请求消息发往Topic交换器。交换器根据不同的routing-key将系统请求消息转发到不同的类型的消息队列。Topic消息消费者探测到新消息已进入响应队列，立即从队列中接收消息并调用执行系统消息所请求的应用程序。</p>

<ul>
<li><p><em>点到点消息队列</em>：Topic消息消费者应用程序接收RPC.CALL的远程调用请求，并在执行相关计算任务之后将结果以系统响应消息的方式通过Direct交换器反馈给Direct消息消费者。</p></li>
<li><p><em>共享消息队列</em>：Topic消息消费者应用程序只是接收RPC.CAST的远程调用请求来执行相关的计算任务，并没有响应消息反馈。</p></li>
</ul>
</li>
<li><p><strong>topic exchange domain:</strong> Direct交换域并不是独立运作，而是受限于Topic交换域中RPC.CALL的远程调用流程与结果，每一个RPC.CALL激活一次Direct消息交换的运作。</p></li>
</ul>


<p><img src="http://chyufly.github.io/images/RPC_Nova_domain.PNG"></p>

<p><em>以nova启动虚拟机的过程为例，详细介绍RPC通信过程。</em></p>

<p><img src="http://chyufly.github.io/images/RPC_Nova_rpcCALL.PNG"></p>

<p>   RPC.CAST缺少了系统消息响应流程。一个Topic消息生产者发送系统请求消息到Topic交换器，Topic交换器根据消息的Routing Key将消息转发至共享消息队列，与共享消息队列相连的所有Topic消费者接收该系统请求消息，并把它传递给响应的Worker进行处理，其调用流程如图所示：</p>

<p><img src="http://chyufly.github.io/images/RPC_Nova_rpcCAST.PNG"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RabbitMQ分布式集群架构和高可用性（HA）]]></title>
    <link href="http://chyufly.github.io/blog/2016/04/10/rabbitmq-cluster/"/>
    <updated>2016-04-10T14:27:17+08:00</updated>
    <id>http://chyufly.github.io/blog/2016/04/10/rabbitmq-cluster</id>
    <content type="html"><![CDATA[<hr />

<h3>(一） 功能和原理</h3>

<p><strong>设计集群的目的</strong></p>

<ul>
<li>允许消费者和生产者在RabbitMQ节点崩溃的情况下继续运行</li>
<li>通过增加更多的节点来扩展消息通信的吞吐量</li>
</ul>


<h4>1 集群配置方式</h4>

<p> RabbitMQ可以通过三种方法来部署分布式集群系统，分别是：cluster,federation,shovel</p>

<ul>
<li><p><strong>cluster:</strong></p>

<ul>
<li>不支持跨网段，用于同一个网段内的局域网</li>
<li>可以随意的动态增加或者减少</li>
<li>节点之间需要运行相同版本的RabbitMQ和Erlang</li>
</ul>
</li>
<li><p><strong>federation:</strong>应用于广域网，允许单台服务器上的交换机或队列接收发布到另一台服务器上交换机或队列的消息，可以是单独机器或集群。federation队列类似于单向点对点连接，消息会在联盟队列之间转发任意次，直到被消费者接受。通常使用federation来连接internet上的中间服务器，用作订阅分发消息或工作队列。</p></li>
<li><p><strong>shovel:</strong>连接方式与federation的连接方式类似，但它工作在更低层次。可以应用于广域网。</p></li>
</ul>


<h4>2 节点类型</h4>

<ul>
<li><p><strong>RAM node:</strong>内存节点将所有的队列、交换机、绑定、用户、权限和vhost的<strong><em>元数据</em></strong>定义存储在内存中，好处是可以使得像交换机和队列声明等操作更加的快速。</p></li>
<li><p><strong>Disk node:</strong>将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启RabbitMQ的时候，丢失系统的配置信息。</p></li>
</ul>


<blockquote><p><strong>问题说明：</strong> RabbitMQ要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入或者离开集群时，必须要将该变更通知到至少一个磁盘节点。如果集群中唯一的一个磁盘节点崩溃的话，集群仍然可以保持运行，但是无法进行其他操作（增删改查），直到节点恢复。</p>

<p><strong>解决方案：</strong>设置两个磁盘节点，至少有一个是可用的，可以保存元数据的更改。</p></blockquote>

<h4>3 Erlang Cookie</h4>

<p><a href="http://www.rabbitmq.com/clustering.html">Erlang Cookie</a>是保证不同节点可以相互通信的密钥，要保证集群中的不同节点相互通信必须共享相同的Erlang Cookie。具体的目录存放在/var/lib/rabbitmq/.erlang.cookie。</p>

<blockquote><p><strong>说明：</strong> 这就要从rabbitmqctl命令的工作原理说起，RabbitMQ底层是通过Erlang架构来实现的，所以rabbitmqctl会启动Erlang节点，并基于Erlang节点来使用Erlang系统连接RabbitMQ节点，在连接过程中需要正确的Erlang Cookie和节点名称，Erlang节点通过交换Erlang Cookie以获得认证。</p></blockquote>

<h4>4 镜像队列</h4>

<p><strong><em>功能和原理</em></strong>
RabbitMQ的Cluster集群模式一般分为两种，普通模式和镜像模式。</p>

<ul>
<li><strong>普通模式：</strong>默认的集群模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于Queue来说，消息实体只存在于其中一个节点rabbit01（或者rabbit02），rabbit01和rabbit02两个节点仅有相同的元数据，即队列的结构。当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01、rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么得等rabbit01节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。</li>
</ul>


<p><img src="http://chyufly.github.io/images/RabbitMQ_cluster_imag.PNG"></p>

<p>下面表示在集群配置下的不同节点创建队列的情况</p>

<p><img src="http://chyufly.github.io/images/RabbitMQ_cluster_queues.PNG"></p>

<p>下图表示在集群配置下的不同节点创建交换器和队列的绑定的情况</p>

<p><img src="http://chyufly.github.io/images/RabbitMQ_cluster_exchanges.PNG"></p>

<ul>
<li><strong>镜像模式：</strong>将需要消费的队列变为镜像队列，存在于多个节点，这样就可以实现RabbitMQ的HA高可用性。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在consumer消费数据时临时读取。缺点就是，集群内部的同步通讯会占用大量的网络带宽。</li>
</ul>


<p><img src="http://chyufly.github.io/images/RabbitMQ_image_queues.PNG"></p>

<p><strong><em>实现机制</em></strong>
镜像队列实现了RabbitMQ的高可用性（HA），具体的实现策略如下所示：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> ha-mode  </th>
<th>ha-params  </th>
<th> 功能  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> all      </td>
<td> 空        </td>
<td>  镜像队列将会在整个集群中复制。当一个新的节点加入后，也会在这       个节点上复制一份。   </td>
</tr>
<tr>
<td style="text-align:left;"> exactly  </td>
<td>count      </td>
<td>  镜像队列将会在集群上复制count份。如果集群数量少于count时候，队列会复制到所有节点上。如果大于Count集群，有一个节点crash后，新进入节点也不会做新的镜像。  </td>
</tr>
<tr>
<td style="text-align:left;"> nodes    </td>
<td> node name </td>
<td> 镜像队列会在node name中复制。如果这个名称不是集群中的一个，这不会触发错误。如果在这个node list中没有一个节点在线，那么这个queue会被声明在client连接的节点。    </td>
</tr>
</tbody>
</table>


<p>实例列举：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>queue_args("x-ha-policy":"all") //定义字典来设置额外的队列声明参数
</span><span class='line'>channel.queue_declare(queue="hello-queue",argument=queue_args)</span></code></pre></td></tr></table></div></figure>


<p>如果需要设定特定的节点（以rabbit@localhost为例），再添加一个参数</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>queue_args("x-ha-policy":"nodes",
</span><span class='line'>           "x-ha-policy-params":["rabbit@localhost"])
</span><span class='line'>channel.queue_declare(queue="hello-queue",argument=queue_args)</span></code></pre></td></tr></table></div></figure>


<p>可以通过命令行查看那个主节点进行了同步</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rabbitmqctl list_queue name slave_pids synchronised_slave_pids</span></code></pre></td></tr></table></div></figure>


<h3>(二） RabbitMQ Cluster 配置</h3>

<h4>1 单机多节点部署</h4>

<p>在启动RabbitMQ节点之后，服务器默认的节点名称是Rabbit和监听端口5672，如果想在同一台机器上启动多个节点，那么其他的节点就会因为节点名称和端口与默认的冲突而导致启动失败，可以通过设置环境变量来实现，具体方法如下：</p>

<ul>
<li><strong>首先在机器上设置两个节点rabbit和rabbit_01</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rabbitmqctl stop //先停止运行节点，再进行集群部署
</span><span class='line'>RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit //设置环境变量指定端口和节点名称
</span><span class='line'>rabbitmq-server -detached //后台启动节点
</span><span class='line'>RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit_01 //设置环境变量指定端口和节点名称
</span><span class='line'>rabbitmq-server -detached //后台启动节点</span></code></pre></td></tr></table></div></figure>


<p>或者通过添加/etc/rabbitmq/rabbitmq-env.conf文件来进行设置：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>NODE_PORT=5672
</span><span class='line'>NODENAME=rabbit
</span><span class='line'>NODE_PORT=5673
</span><span class='line'>NODENAME=rabbit_01</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>将rabbit_01节点添加到第一个集群节点rabbit中</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rabbitmqctl -n rabbit_01@localhost stop_app //停止rabbit_01节点的应用
</span><span class='line'>rabbitmqctl -n rabbit_01@localhost join_cluster rabbit@localhost //将rabbit_01添加到集群节点rabbit中去
</span><span class='line'>rabbitmqctl cluster_status //查看集群节点的状态
</span><span class='line'>rabbitmqctl -n rabbit_01@localhost start_app //启动rabbit_01节点的应用</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//可以看到如下信息，说明节点添加成功，表明都是磁盘类型的节点
</span><span class='line'>Cluster status of node rabbit@localhost ...
</span><span class='line'>[{nodes,[{disc,[rabbit@localhost,rabbit_01@localhost]}]},
</span><span class='line'> {running_nodes,[rabbit@localhost]},
</span><span class='line'> {cluster_name,&lt;&lt;"rabbit@localhost"&gt;&gt;},
</span><span class='line'> {partitions,[]},
</span><span class='line'> {alarms,[{rabbit@localhost,[]}]}]</span></code></pre></td></tr></table></div></figure>


<h4>2 多机多节点部署</h4>

<p><em>不同于单机多节点的情况，在多机环境，如果要在cluster集群内部署多个节点，需要注意两个方面：</em></p>

<ul>
<li><strong>保证需要部署的这几个节点在同一个局域网内</strong></li>
<li><strong>需要有相同的Erlang Cookie，否则不能进行通信，为保证cookie的完全一致，采用从一个节点copy的方式</strong></li>
</ul>


<p><strong><em>环境介绍</em></strong>：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> RabbitMQ节点      </th>
<th>    IP地址       </th>
<th> 工作模式  </th>
<th>操作系统          </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> rabbitmqCluster  </td>
<td> 192.168.118.133 </td>
<td>  DISK   </td>
<td>CentOS 7.0 - 64位</td>
</tr>
<tr>
<td style="text-align:left;"> rabbitmqCluster01</td>
<td> 192.168.118.134 </td>
<td>  DISK   </td>
<td>CentOS 7.0 - 64位</td>
</tr>
<tr>
<td style="text-align:left;"> rabbitmqCluster02</td>
<td> 192.168.118.135 </td>
<td> DISK    </td>
<td>CentOS 7.0 - 64位</td>
</tr>
</tbody>
</table>


<p><img src="http://chyufly.github.io/images/RabbitMQ_clusterALL.PNG"></p>

<p><strong><em>cluster部署过程</em></strong>：</p>

<ul>
<li><strong>局域网配置</strong>
分别在三个节点的/etc/hosts下设置相同的配置信息</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>  192.168.118.133 rabbitmqCluster
</span><span class='line'>  192.168.118.134 rabbitmqCluster01
</span><span class='line'>  192.168.118.135 rabbitmqCluster02</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>设置不同节点间同一认证的Erlang Cookie</strong>
采用从主节点copy的方式保持Cookie的一致性</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@rabbitmqCluster01]# scp /var/lib/rabbitmq/.erlang.cookie 192.168.118.134:/var/lib/rabbitmq
</span><span class='line'>[root@rabbitmqCluster02]# scp /var/lib/rabbitmq/.erlang.cookie 192.168.118.135:/var/lib/rabbitmq</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>使用 -detached运行各节点</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rabbitmqctl stop
</span><span class='line'>rabbitmq-server -detached </span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>查看各节点的状态</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@rabbitmqCluster]#rabbitmqctl cluster_status
</span><span class='line'>[root@rabbitmqCluster01]#rabbitmqctl cluster_status
</span><span class='line'>[root@rabbitmqCluster02]#rabbitmqctl cluster_status</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>创建并部署集群</strong>，以rabbitmqCluster01节点为例：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@rabbitmqCluster01]#rabbitmqctl stop_app
</span><span class='line'>[root@rabbitmqCluster01]#rabbitmqctl join_cluster rabbit@rabbitmqCluster
</span><span class='line'>[root@rabbitmqCluster01]#rabbitmqctl start_app</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>查看集群状态</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[root@rabbitmqCluster]#rabbitmqctl cluster_status</span></code></pre></td></tr></table></div></figure>


<h2>RabbitMQ负载均衡配置</h2>

<p><strong><em>前言：</em></strong>从目前来看，基于RabbitMQ的分布式通信框架主要包括两部分内容，一是要确保可用性和性能，另一个就是编写当节点发生故障时知道如何重连到集群的应用程序。负载均衡就是解决处理节点的选择问题。</p>

<p><img src="http://chyufly.github.io/images/RabbitMQ_loadbalance.jpg"></p>

<h3>安装HAProxy</h3>

<p>选择开源的HAProxy为RabbitMQ集群做负载均衡器，在CentOS 7.0中安装HAProxy。</p>

<ul>
<li><strong>安装epel</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpm -ivh http://download.fedoraproject.org/pub/epel/6/i386/epel-release-6-5.noarch.rpm//</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>安装HAProxy</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>yum -y install haproxy</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>配置HAProxy</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>cp /etc/haproxy/haproxy.cfg /etc/haproxy/haproxy.cfg.bak
</span><span class='line'>vim /etc/haproxy/haproxy.cfg</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>添加配置信息</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>listen rabbitmq_local_cluster 127.0.0.1:5670 //前段IP，供product和consumer来进行选择，由于5672端口已经默认使用，这里选择5670端口
</span><span class='line'>     mode tcp   //负载均衡选项
</span><span class='line'>     balance roundrobin //轮询算法将负载发给后台服务器
</span><span class='line'>     server rabbit 127.0.0.1:5672 check inter 5000 rise 2 fall 3//负载均衡中的集群节点配置，这里选择的rabbit节点
</span><span class='line'>  
</span><span class='line'>  listen private_monitoring :8100
</span><span class='line'>     mode http
</span><span class='line'>     option httplog
</span><span class='line'>     stats enable
</span><span class='line'>     stats uri       /stats
</span><span class='line'>     stats refresh 60s</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>设置开机启动</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>chkconfig haproxy on
</span><span class='line'>service haproxy start</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>访问localhost:8100/stats就可以看到具体的控制界面。</strong></li>
</ul>


<p><img src="http://chyufly.github.io/images/HA_web.PNG"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RabbitMQ安装和使用]]></title>
    <link href="http://chyufly.github.io/blog/2016/04/10/rabbitmq-setup/"/>
    <updated>2016-04-10T00:00:00+08:00</updated>
    <id>http://chyufly.github.io/blog/2016/04/10/rabbitmq-setup</id>
    <content type="html"><![CDATA[<hr />

<h2>RabbitMQ安装步骤</h2>

<ul>
<li><strong><em>虚拟机：VMware workstation 12.0</em></strong></li>
<li><strong><em>Linux系统：CentOS 7.0</em></strong>

<h3>安装Erlang环境</h3>

<p>由于RabbitMQ是采用<strong>Erlang</strong>编写的，首先需要安装该语言库，以便运行代理服务器，可以参考<a href="https://www.erlang-solutions.com/downloads/download-erlang-otp">Erlang官方文档</a>。</p></li>
<li><strong>erlang-solution配置信息安装</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm
</span><span class='line'>sudo rpm -Uvh erlang-solutions-1.0-1.noarch.rpm
</span><span class='line'>rpm --import http://packages.erlang-solutions.com/rpm/erlang_solutions.asc
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>第三方yum源依赖</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget http://packages.sw.be/rpmforge-release/rpmforge-release-0.5.2-2.el6.rf.x86_64.rpm
</span><span class='line'>rpm –import http://apt.sw.be/RPM-GPG-KEY.dag.txt
</span><span class='line'>sudo rpm -i rpmforge-release-0.5.2-2.el6.rf.*.rpm</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>安装erlang</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo yum install erlang</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>运行<em>erl</em>命令进行测试</strong></li>
</ul>


<h3>安装RabbitMQ</h3>

<ul>
<li><strong>首先下载最新版的RabbitMQ</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.1/rabbitmq-server-3.6.1-1.noarch.rpm</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>使用rpm和yum进行安装</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rpm --import http://www.rabbitmq.com/rabbitmq-signing-key-public.asc
</span><span class='line'>yum install rabbitmq-server-3.6.1-1.noarch.rpm</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>启动RabbitMQ管理插件，用于web界面管理</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rabbitmq-plugins enable rabbitmq_management
</span><span class='line'>service rabbitmq-server restart</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>测试安装完成的RabbitMQ</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rabbitmqctl status</span></code></pre></td></tr></table></div></figure>


<p>具体内容可以参考<a href="http://www.rabbitmq.com/install-rpm.html">RabbitMQ安装</a>官方文档。</p>

<blockquote><p><strong>注意：</strong>在Ubuntu下安装RabbitMQ非常简单，系统已经默认安装Erlang环境，使用<em>apt-get install rabbitmq-server</em>即可安装。</p></blockquote>

<h2>RabbitMQ使用和管理</h2>

<h3>后台操作命令管理RabbitMQ</h3>

<p><em>rabbitmqctl</em>是RabbitMQ中间件的一个命令行管理工具，原理就是通过连接一个中间件的节点执行所有的动作，本地节点默认为“rabbit”，<em>rabbitmqctl</em>来指定RabbitMQ中间件在本地节点<strong>rabbit@localhost</strong>进行管理操作。</p>

<blockquote><p><strong>注意：</strong>在使用<em>rabbitmqctl</em>命令时，可以用<strong>-n</strong>标志来明确指定的节点，比如<em>rabbitmqctl -n rabbit@localhost &hellip;</em>，在使用默认节点的情况下，这个可以省略。</p></blockquote>

<h4><strong>常用命令列举</strong></h4>

<ul>
<li><strong>应用管理</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rabbitmqctl status //显示RabbitMQ中间件的所有信息
</span><span class='line'>rabbitmqctl stop //停止RabbitMQ应用，关闭节点
</span><span class='line'>rabbitmqctl stop_app //停止RabbitMQ应用
</span><span class='line'>rabbitmqctl start_app //启动RabbitMQ应用
</span><span class='line'>rabbitmqctl restart //重置RabbitMQ节点
</span><span class='line'>rabbitmqctl force_restart //强制重置RabbitMQ节点</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>用户管理</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rabbitmqctl add_user username password //添加用户
</span><span class='line'>rabbitmqctl delete_user username //删除用户
</span><span class='line'>rabbitmqctl change_password username newpassword //修改密码
</span><span class='line'>rabbitmqctl list_users //列出所有用户</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>权限控制管理</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> rabbitmqctl add_vhost vhostpath //创建虚拟主机
</span><span class='line'> rabbitmqctl delete_vhost vhostpath //删除虚拟主机
</span><span class='line'> rabbitmqctl list_vhosts //列出所有虚拟主机
</span><span class='line'> rabbitmqctl set_permissions [-p vhostpath] username &lt;conf&gt; &lt;write&gt; &lt;read&gt; //设置用户权限
</span><span class='line'> rabbitmqctl clear_permissions [-p vhostpath] username //删除用户权限
</span><span class='line'> rabbitmqctl list_permissions [-p vhostpath] //列出虚拟机上的所有权限
</span><span class='line'> rabbitmqctl list_user_permissions username //列出用户权限</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>集群管理</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rabbitmqctl cluster_status //获得集群配置信息
</span><span class='line'>rabbitmqctl join_cluster rabbit@localhost --ram | --disc //加入到rabbit节点中，使用内存模式或者磁盘模式
</span><span class='line'>rabbitmqctl change_cluster_node_type disc | ram //修改存储模式
</span><span class='line'>rabbitmqctl set_cluster_name newname //修改名字</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>查看管理</strong></li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> rabbitmqctl list_queues [-p &lt;vhostpath&gt;]  //查看所有队列
</span><span class='line'> rabbitmqctl list_exchanges [-p &lt;vhostpath&gt;] //查看所有交换机
</span><span class='line'> rabbitmqctl list_bindings [-p &lt;vhostpath&gt;] //查看所有绑定
</span><span class='line'> rabbitmqctl list_connections //查看所有连接
</span><span class='line'> rabbitmqctl list_channels //查看所有信道
</span><span class='line'> rabbitmqctl list_consumers //查看所有消费者信息</span></code></pre></td></tr></table></div></figure>


<h3>Web界面管理RabbitMQ</h3>

<p>RabbitMQ通过使用<em>RabbitMQ Management</em> 插件的Web界面来管理用户、队列和交换器。</p>

<p><strong>Web界面包含的内容</strong></p>

<ul>
<li> 服务器数据统计概览</li>
<li> 导入/导出服务器配置</li>
<li> 监控服务器连接</li>
<li> 信道列表</li>
<li> 交换器列表、添加交换器</li>
<li> 队列列表、添加队列</li>
<li> 修改队列绑定</li>
<li> 用户列表、添加用户</li>
<li> 查看vhost、添加vhost</li>
</ul>


<blockquote><p><strong>注意：</strong>使用<strong><em>rabbitmq-plugins enable rabbitmq_management</em></strong>来启动Management插件。
默认是可以本地登录<strong><em>localhost:15672</em></strong>，用户名：guest；密码：guest；端口默认15672。</p></blockquote>

<p><img src="http://chyufly.github.io/images/RabbitMQ_web.PNG"></p>

<h3>CLI管理</h3>

<p>在web界面上还有两个选项，<strong>HTTP API</strong>和<strong>CLT</strong>。</p>

<ul>
<li><a href="http://localhost:15672/api">HTTP API</a>：提供了一个关于REST接口的文档界面，Web界面可以完成的功能，都可以通过使用curl并调用API命令来完成。比如需要列出服务器上的vhost的话，在终端执行下列代码即可：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -i -u guest:guest http://localhost:15672/api/vhosts  </span></code></pre></td></tr></table></div></figure>


<ul>
<li><a href="http://localhost:15672/cli">CLI</a>：主要是Python脚本，相比于REST的API好处是，不需要手工编写请求，rabbitmqadmin会包装REST API，使用干净的接口与其交互，举例来说：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>curl -i -u guest:guest http://localhost:15672/api/queues //使用REST API</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>./rabbitmqadmin list queues   //使用CLI</span></code></pre></td></tr></table></div></figure>


<h4><strong>rabbitmqadmin脚本安装</strong></h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget http://localhost:15672/cli/rabbitmqadmin
</span><span class='line'>chmod +x rabbitmqadmin</span></code></pre></td></tr></table></div></figure>


<h3><strong>总结</strong></h3>

<p>三种管理方式各有特点：</p>

<ul>
<li><strong>Web UI</strong>对于日常的开发更加简单，可以通过视图查看服务器的状态，方便观察。</li>
<li><strong>REST API</strong>可以自动化这些任务，并通过curl来调用，得到JSON对象后就可以集成到当前的工具和语言中。</li>
<li><strong>rabbitmqadmin</strong>脚本不需要手工构造通过curl发送的HTTP请求，获得更加简介易懂的格式化输出，帮助管理和监控RabbitMQ。</li>
</ul>

]]></content>
  </entry>
  
</feed>
